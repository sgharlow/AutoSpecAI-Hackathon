"""
Configuration Management Module for AutoSpec.AI

This module provides centralized configuration management for Lambda functions,
loading environment-specific settings and providing type-safe access to
configuration values.

Usage:
    from shared.config import get_config, ConfigManager
    
    config = get_config()
    max_file_size = config.processing.file_limits.max_size_mb
    
    # Or use the manager directly
    config_manager = ConfigManager()
    bedrock_model = config_manager.get('bedrock.model_id')
"""

import os
import json
from typing import Any, Dict, Optional, Union
from dataclasses import dataclass, field
from pathlib import Path

@dataclass
class FileLimits:
    """File processing limits configuration."""
    max_size_mb: int = 10
    allowed_extensions: list = field(default_factory=lambda: ['.pdf', '.docx', '.doc', '.txt'])
    supported_mime_types: dict = field(default_factory=dict)

@dataclass
class RateLimiting:
    """Rate limiting configuration."""
    requests_per_hour: int = 100
    window_seconds: int = 3600
    burst_limit: int = 10
    enabled: bool = True

@dataclass
class TextExtraction:
    """Text extraction configuration."""
    preview_char_limit: int = 500
    prompt_char_limit: int = 8000

@dataclass
class ProcessingConfig:
    """Processing-related configuration."""
    file_limits: FileLimits = field(default_factory=FileLimits)
    rate_limiting: RateLimiting = field(default_factory=RateLimiting)
    text_extraction: TextExtraction = field(default_factory=TextExtraction)

@dataclass
class BedrockConfig:
    """Amazon Bedrock configuration."""
    model_id: str = "anthropic.claude-3-5-sonnet-20241022-v2:0"
    max_tokens: int = 4000
    temperature: float = 0.1
    top_p: float = 0.9
    timeout_seconds: int = 300

@dataclass
class ColorScheme:
    """UI color scheme configuration."""
    primary: str = "#3498db"
    secondary: str = "#2c3e50"
    accent: str = "#e74c3c"

@dataclass
class BrandingConfig:
    """Branding and white-label configuration."""
    company_name: str = "AutoSpec.AI"
    website_url: str = "https://autospec.ai"
    support_email: str = "support@autospec.ai"
    api_base_url: str = "https://api.autospec.ai/v1"
    logo_url: str = ""
    color_scheme: ColorScheme = field(default_factory=ColorScheme)

@dataclass
class EmailTemplates:
    """Email template configuration."""
    subject_template: str = "AutoSpec.AI - System Requirements for {filename}"
    from_name: str = "AutoSpec.AI"
    default_sender: str = "api-user@autospec.ai"

@dataclass
class PDFTemplates:
    """PDF template configuration."""
    footer_template: str = "Generated by {company_name}"
    title_template: str = "System Requirements Analysis - {filename}"

@dataclass
class ErrorMessages:
    """Error message templates."""
    file_too_large: str = "File size exceeds the maximum allowed limit of {max_size_mb}MB"
    unsupported_format: str = "Unsupported file format. Please use: {allowed_formats}"
    processing_failed: str = "Document processing failed. Please try again or contact support."

@dataclass
class TemplatesConfig:
    """Template configuration."""
    email: EmailTemplates = field(default_factory=EmailTemplates)
    pdf: PDFTemplates = field(default_factory=PDFTemplates)
    error_messages: ErrorMessages = field(default_factory=ErrorMessages)

@dataclass
class SlackIntegration:
    """Slack integration configuration."""
    webhook_url: str = ""
    signing_secret: str = ""
    help_url: str = "https://autospec.ai/help"
    timeout_seconds: int = 300

@dataclass
class ExternalAPIs:
    """External API configuration."""
    plotly_cdn: str = "https://cdn.plot.ly/plotly-latest.min.js"
    chart_timeout_seconds: int = 30

@dataclass
class IntegrationsConfig:
    """External integrations configuration."""
    slack: SlackIntegration = field(default_factory=SlackIntegration)
    external_apis: ExternalAPIs = field(default_factory=ExternalAPIs)

@dataclass
class SecurityConfig:
    """Security configuration."""
    api_key_required: bool = True
    cors_origins: list = field(default_factory=lambda: ["*"])
    max_request_size_mb: int = 10
    encryption_at_rest: bool = True
    encryption_in_transit: bool = True

@dataclass
class ResourceNaming:
    """Resource naming patterns."""
    bucket_pattern: str = "autospec-ai-documents-{environment}-{account}"
    table_prefix: str = "autospec-ai-{environment}"
    function_prefix: str = "AutoSpecAI-{environment}"

@dataclass
class AutoSpecConfig:
    """Main configuration class containing all settings."""
    environment: str = "dev"
    processing: ProcessingConfig = field(default_factory=ProcessingConfig)
    bedrock: BedrockConfig = field(default_factory=BedrockConfig)
    branding: BrandingConfig = field(default_factory=BrandingConfig)
    templates: TemplatesConfig = field(default_factory=TemplatesConfig)
    integrations: IntegrationsConfig = field(default_factory=IntegrationsConfig)
    security: SecurityConfig = field(default_factory=SecurityConfig)
    resource_naming: ResourceNaming = field(default_factory=ResourceNaming)

class ConfigManager:
    """Configuration manager for loading and accessing configuration."""
    
    def __init__(self, environment: Optional[str] = None):
        self.environment = environment or os.environ.get('ENVIRONMENT', 'dev')
        self._config_cache: Optional[AutoSpecConfig] = None
        self._raw_config_cache: Optional[Dict[str, Any]] = None
    
    def _load_raw_config(self) -> Dict[str, Any]:
        """Load raw configuration from environment variables and files."""
        if self._raw_config_cache is not None:
            return self._raw_config_cache
        
        # Start with default configuration
        config = {}
        
        # Try to load from config file
        config_file = self._find_config_file()
        if config_file and config_file.exists():
            try:
                with open(config_file, 'r') as f:
                    file_config = json.load(f)
                    config.update(file_config)
            except (FileNotFoundError, json.JSONDecodeError) as e:
                print(f"Warning: Could not load config file {config_file}: {e}")
        
        # Override with environment variables
        env_overrides = self._extract_env_overrides()
        config = self._merge_configs(config, env_overrides)
        
        self._raw_config_cache = config
        return config
    
    def _find_config_file(self) -> Optional[Path]:
        """Find the configuration file for the current environment."""
        # Look for config file in multiple locations
        possible_paths = [
            # Lambda function context
            Path(f"/opt/config/environments/{self.environment}.json"),
            # Development context
            Path(__file__).parent.parent.parent / "config" / "environments" / f"{self.environment}.json",
            # Alternative locations
            Path(f"./config/environments/{self.environment}.json"),
            Path(f"./config/{self.environment}.json"),
        ]
        
        for path in possible_paths:
            if path.exists():
                return path
        
        return None
    
    def _extract_env_overrides(self) -> Dict[str, Any]:
        """Extract configuration overrides from environment variables."""
        overrides = {}
        
        # Define environment variable mappings
        env_mappings = {
            # Processing
            'MAX_FILE_SIZE_MB': 'processing.file_limits.max_size_mb',
            'RATE_LIMIT_REQUESTS': 'processing.rate_limiting.requests_per_hour',
            'RATE_LIMIT_WINDOW': 'processing.rate_limiting.window_seconds',
            
            # Bedrock
            'BEDROCK_MODEL_ID': 'bedrock.model_id',
            'BEDROCK_MAX_TOKENS': 'bedrock.max_tokens',
            'BEDROCK_TEMPERATURE': 'bedrock.temperature',
            'BEDROCK_TOP_P': 'bedrock.top_p',
            
            # Branding
            'COMPANY_NAME': 'branding.company_name',
            'WEBSITE_URL': 'branding.website_url',
            'SUPPORT_EMAIL': 'branding.support_email',
            'API_BASE_URL': 'branding.api_base_url',
            
            # Security
            'API_KEY_REQUIRED': 'security.api_key_required',
            'CORS_ORIGINS': 'security.cors_origins',
            
            # Integrations
            'SLACK_WEBHOOK_URL': 'integrations.slack.webhook_url',
            'SLACK_SIGNING_SECRET': 'integrations.slack.signing_secret',
            
            # Email
            'FROM_EMAIL': 'templates.email.default_sender',
            'EMAIL_SUBJECT_TEMPLATE': 'templates.email.subject_template',
        }
        
        for env_var, config_path in env_mappings.items():
            value = os.environ.get(env_var)
            if value is not None:
                # Convert string values to appropriate types
                if value.lower() in ('true', 'false'):
                    value = value.lower() == 'true'
                elif value.isdigit():
                    value = int(value)
                elif self._is_float(value):
                    value = float(value)
                elif value.startswith('[') and value.endswith(']'):
                    # Simple list parsing
                    try:
                        value = json.loads(value)
                    except json.JSONDecodeError:
                        pass
                
                self._set_nested_value(overrides, config_path, value)
        
        return overrides
    
    def _is_float(self, value: str) -> bool:
        """Check if a string represents a float."""
        try:
            float(value)
            return True
        except ValueError:
            return False
    
    def _set_nested_value(self, config: Dict[str, Any], path: str, value: Any):
        """Set a nested configuration value using dot notation."""
        keys = path.split('.')
        current = config
        
        for key in keys[:-1]:
            if key not in current:
                current[key] = {}
            current = current[key]
        
        current[keys[-1]] = value
    
    def _merge_configs(self, base: Dict[str, Any], override: Dict[str, Any]) -> Dict[str, Any]:
        """Merge two configuration dictionaries."""
        result = base.copy()
        
        for key, value in override.items():
            if isinstance(value, dict) and key in result and isinstance(result[key], dict):
                result[key] = self._merge_configs(result[key], value)
            else:
                result[key] = value
        
        return result
    
    def _create_dataclass_from_dict(self, data_class, config_dict: Dict[str, Any]):
        """Create a dataclass instance from a configuration dictionary."""
        if not isinstance(config_dict, dict):
            return data_class()
        
        kwargs = {}
        for field_info in data_class.__dataclass_fields__.values():
            field_name = field_info.name
            if field_name in config_dict:
                field_value = config_dict[field_name]
                
                # Handle nested dataclasses
                if hasattr(field_info.type, '__dataclass_fields__'):
                    field_value = self._create_dataclass_from_dict(field_info.type, field_value)
                
                kwargs[field_name] = field_value
        
        return data_class(**kwargs)
    
    def get_config(self) -> AutoSpecConfig:
        """Get the typed configuration object."""
        if self._config_cache is not None:
            return self._config_cache
        
        raw_config = self._load_raw_config()
        
        # Create configuration object
        config = AutoSpecConfig(
            environment=self.environment,
            processing=self._create_dataclass_from_dict(ProcessingConfig, raw_config.get('processing', {})),
            bedrock=self._create_dataclass_from_dict(BedrockConfig, raw_config.get('bedrock', {})),
            branding=self._create_dataclass_from_dict(BrandingConfig, raw_config.get('branding', {})),
            templates=self._create_dataclass_from_dict(TemplatesConfig, raw_config.get('templates', {})),
            integrations=self._create_dataclass_from_dict(IntegrationsConfig, raw_config.get('integrations', {})),
            security=self._create_dataclass_from_dict(SecurityConfig, raw_config.get('security', {})),
            resource_naming=self._create_dataclass_from_dict(ResourceNaming, raw_config.get('resource_naming', {}))
        )
        
        self._config_cache = config
        return config
    
    def get(self, key: str, default: Any = None) -> Any:
        """Get a configuration value using dot notation."""
        raw_config = self._load_raw_config()
        
        keys = key.split('.')
        current = raw_config
        
        try:
            for k in keys:
                current = current[k]
            return current
        except (KeyError, TypeError):
            return default
    
    def get_resource_name(self, pattern: str, **kwargs) -> str:
        """Generate a resource name using the configured pattern."""
        # Add default substitutions
        substitutions = {
            'environment': self.environment,
            'account': os.environ.get('AWS_ACCOUNT_ID', 'unknown'),
            **kwargs
        }
        
        return pattern.format(**substitutions)

# Global configuration manager instance
_config_manager: Optional[ConfigManager] = None

def get_config() -> AutoSpecConfig:
    """Get the global configuration instance."""
    global _config_manager
    if _config_manager is None:
        _config_manager = ConfigManager()
    return _config_manager.get_config()

def get_config_manager() -> ConfigManager:
    """Get the global configuration manager instance."""
    global _config_manager
    if _config_manager is None:
        _config_manager = ConfigManager()
    return _config_manager

def reset_config_cache():
    """Reset the configuration cache (useful for testing)."""
    global _config_manager
    if _config_manager is not None:
        _config_manager._config_cache = None
        _config_manager._raw_config_cache = None