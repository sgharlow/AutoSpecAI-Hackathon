import json
import unittest
from unittest.mock import patch, MagicMock
import sys
import os

# Add the current directory to the path so we can import index
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

import index

class TestFormatFunction(unittest.TestCase):
    
    def setUp(self):
        """Set up test fixtures."""
        # Mock environment variables
        os.environ['DOCUMENT_BUCKET'] = 'test-bucket'
        os.environ['HISTORY_TABLE'] = 'test-table'
        os.environ['FROM_EMAIL'] = 'test@autospec.ai'
        
        # Sample request data
        self.sample_request_data = {
            'requestId': 'test-request-123',
            'timestamp': '2024-01-01T00:00:00Z',
            'filename': 'test_document.pdf',
            'senderEmail': 'user@example.com',
            'fileType': 'pdf',
            'status': 'processed',
            'aiResponse': {
                'raw_response': '## Executive Summary\nTest system overview.\n\n## Functional Requirements\n- Feature 1\n- Feature 2',
                'model_used': 'anthropic.claude-3-sonnet-20240229-v1:0',
                'generated_at': '2024-01-01T00:00:00Z',
                'processing_status': 'completed',
                'requirements_sections': {
                    'executive_summary': 'Test system overview.',
                    'functional_requirements': '- Feature 1\n- Feature 2'
                }
            }
        }
    
    def test_generate_markdown_output(self):
        """Test Markdown output generation."""
        raw_response = self.sample_request_data['aiResponse']['raw_response']
        sections = self.sample_request_data['aiResponse']['requirements_sections']
        
        markdown_output = index.generate_markdown_output(raw_response, sections, self.sample_request_data)
        
        # Check that output contains expected elements
        self.assertIn('# System Requirements Analysis', markdown_output)
        self.assertIn('test_document.pdf', markdown_output)
        self.assertIn('test-request-123', markdown_output)
        self.assertIn('AutoSpec.AI', markdown_output)
        self.assertIn('Executive Summary', markdown_output)
        self.assertIn('Feature 1', markdown_output)
    
    def test_generate_json_output(self):
        """Test JSON output generation."""
        ai_response = self.sample_request_data['aiResponse']
        
        json_output = index.generate_json_output(ai_response, self.sample_request_data)
        
        # Parse the JSON to verify structure
        json_data = json.loads(json_output)
        
        self.assertIn('metadata', json_data)
        self.assertIn('ai_analysis', json_data)
        self.assertIn('requirements', json_data)
        self.assertIn('raw_response', json_data)
        
        # Check metadata
        self.assertEqual(json_data['metadata']['request_id'], 'test-request-123')
        self.assertEqual(json_data['metadata']['filename'], 'test_document.pdf')
        
        # Check AI analysis
        self.assertEqual(json_data['ai_analysis']['model_used'], 'anthropic.claude-3-sonnet-20240229-v1:0')
        
        # Check requirements sections
        self.assertIn('executive_summary', json_data['requirements'])
        self.assertIn('functional_requirements', json_data['requirements'])
    
    def test_generate_html_output(self):
        """Test HTML output generation."""
        markdown_content = "# Test\n\n## Section 1\n\nContent here."
        
        html_output = index.generate_html_output(markdown_content, self.sample_request_data)
        
        # Check HTML structure
        self.assertIn('<!DOCTYPE html>', html_output)
        self.assertIn('<title>System Requirements - test_document.pdf</title>', html_output)
        self.assertIn('<h1>Test</h1>', html_output)
        self.assertIn('<h2>Section 1</h2>', html_output)
        self.assertIn('Generated by AutoSpec.AI', html_output)
        
        # Check CSS styling
        self.assertIn('font-family:', html_output)
        self.assertIn('color:', html_output)
    
    def test_create_email_body(self):
        """Test email body creation."""
        formatted_outputs = {
            'markdown': 'test markdown',
            'json': 'test json',
            'html': 'test html'
        }
        
        email_body = index.create_email_body(self.sample_request_data, formatted_outputs)
        
        # Check email content
        self.assertIn('Dear User', email_body)
        self.assertIn('test_document.pdf', email_body)
        self.assertIn('test-request-123', email_body)
        self.assertIn('Executive Summary', email_body)
        self.assertIn('Functional Requirements', email_body)
        self.assertIn('AutoSpec.AI Team', email_body)
    
    @patch('index.dynamodb')
    def test_get_request_data(self, mock_dynamodb):
        """Test request data retrieval."""
        # Mock DynamoDB response
        mock_table = MagicMock()
        mock_table.query.return_value = {
            'Items': [self.sample_request_data]
        }
        mock_dynamodb.Table.return_value = mock_table
        
        result = index.get_request_data('test-request-123')
        
        self.assertEqual(result, self.sample_request_data)
        mock_table.query.assert_called_once()
    
    @patch('index.ses_client')
    def test_send_ses_email(self, mock_ses):
        """Test SES email sending."""
        mock_ses.send_email.return_value = {'MessageId': 'test-message-id'}
        
        formatted_outputs = {
            'html': '<html>Test HTML</html>',
            'markdown': 'Test markdown',
            'json': 'test json'
        }
        
        # Should not raise an exception
        index.send_ses_email(
            'user@example.com',
            'Test Subject',
            'Test Body',
            formatted_outputs,
            'test-request-123'
        )
        
        mock_ses.send_email.assert_called_once()
        call_args = mock_ses.send_email.call_args[1]
        
        self.assertEqual(call_args['Destination']['ToAddresses'], ['user@example.com'])
        self.assertEqual(call_args['Message']['Subject']['Data'], 'Test Subject')
    
    @patch('index.dynamodb')
    def test_store_final_results(self, mock_dynamodb):
        """Test storing final results in DynamoDB."""
        mock_table = MagicMock()
        mock_table.query.return_value = {
            'Items': [{'timestamp': '2024-01-01T00:00:00Z'}]
        }
        mock_dynamodb.Table.return_value = mock_table
        
        formatted_outputs = {
            'markdown': 'test markdown content',
            'json': '{"test": "json"}',
            'html': '<html>test</html>',
            'pdf': None
        }
        
        index.store_final_results('test-request-123', formatted_outputs)
        
        # Verify update_item was called
        mock_table.update_item.assert_called_once()
        
        # Check the update expression and values
        call_args = mock_table.update_item.call_args[1]
        self.assertIn('delivery_complete', str(call_args))
        self.assertIn('delivered', str(call_args))
    
    def test_generate_formatted_outputs(self):
        """Test complete formatted output generation."""
        formatted_outputs = index.generate_formatted_outputs(self.sample_request_data)
        
        # Check all formats are generated
        self.assertIn('markdown', formatted_outputs)
        self.assertIn('json', formatted_outputs)
        self.assertIn('html', formatted_outputs)
        self.assertIn('pdf', formatted_outputs)
        
        # Check content
        self.assertIsInstance(formatted_outputs['markdown'], str)
        self.assertIsInstance(formatted_outputs['json'], str)
        self.assertIsInstance(formatted_outputs['html'], str)
        
        # Validate JSON structure
        json_data = json.loads(formatted_outputs['json'])
        self.assertIn('metadata', json_data)
        self.assertIn('requirements', json_data)
    
    @patch('index.dynamodb')
    @patch('index.ses_client')
    def test_process_request_by_id(self, mock_ses, mock_dynamodb):
        """Test complete request processing."""
        # Mock DynamoDB
        mock_table = MagicMock()
        mock_table.query.side_effect = [
            {'Items': [self.sample_request_data]},  # get_request_data
            {'Items': [{'timestamp': '2024-01-01T00:00:00Z'}]}  # get_latest_timestamp
        ]
        mock_dynamodb.Table.return_value = mock_table
        
        # Mock SES
        mock_ses.send_email.return_value = {'MessageId': 'test-message-id'}
        
        # Process the request
        index.process_request_by_id('test-request-123')
        
        # Verify SES was called
        mock_ses.send_email.assert_called_once()
        
        # Verify DynamoDB updates
        self.assertTrue(mock_table.update_item.called)
    
    def test_direct_invocation_event(self):
        """Test direct invocation event handling."""
        event = {'request_id': 'test-request-123'}
        context = {}
        
        with patch('index.process_request_by_id') as mock_process:
            response = index.handler(event, context)
            
            self.assertEqual(response['statusCode'], 200)
            mock_process.assert_called_once_with('test-request-123')
    
    def test_error_handling(self):
        """Test error handling in main handler."""
        event = {'invalid': 'event'}
        context = {}
        
        with patch('index.logger') as mock_logger:
            response = index.handler(event, context)
            
            self.assertEqual(response['statusCode'], 200)  # Should handle gracefully

if __name__ == '__main__':
    unittest.main()